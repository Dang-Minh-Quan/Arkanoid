Index: src/main/java/LogicGamePlay/Update.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package LogicGamePlay;\r\n\r\nimport Interface.GamePlayController;\r\n\r\nimport java.util.concurrent.atomic.AtomicBoolean;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\nimport javafx.application.Platform;\r\n\r\nimport static LogicGamePlay.Specifications.*;\r\n\r\npublic class Update {\r\n\r\n    private GamePlayController controller;\r\n\r\n    public Update(GamePlayController controller) {\r\n        this.controller = controller;\r\n    }\r\n\r\n    public void updateGame(Ball ball, Paddle paddle, Brick[][] brick, AtomicInteger Level, AtomicBoolean gameRestarted, AtomicBoolean gameIsRunning, Render render) {\r\n        updateBrick(ball, Level, brick);\r\n        updatePaddle(paddle, brick, ball, gameRestarted, gameIsRunning, render);\r\n    }\r\n\r\n    private void updateBrick(Ball ball, AtomicInteger Level, Brick[][] brick) {\r\n        if (numBrick <= 0) {\r\n            Level.getAndIncrement();\r\n            if (Level.get() <= LevelMax) {\r\n                builderLevel(ball, brick, Level);\r\n            } else {\r\n                //Level.set(0);\r\n                Platform.runLater(() -> controller.Win());\r\n                //WIN\r\n            }\r\n        } else {\r\n            //numBrick--;\r\n        }\r\n    }\r\n\r\n    public void initializeLevel(Ball ball, Brick[][] brick, AtomicInteger Level) {\r\n        numBrick = 0;\r\n        Level.set(0);\r\n        updateBrick(ball, Level, brick);\r\n    }\r\n\r\n    private void builderLevel(Ball ball, Brick[][] brick, AtomicInteger Level) {\r\n        Map map = new Map();\r\n        if (Level.get() > LevelMax) {\r\n            checkPlay = false;\r\n        } else {\r\n            //ball.resert();\r\n            int[][] a = map.builderMap(Level.get());\r\n            for (int i = 0; i < ROW; i++) {\r\n                for (int j = 0; j < COL; j++) {\r\n                    brick[i][j] = new Brick(i, j);\r\n                    brick[i][j].type = a[i][j];\r\n                    if (brick[i][j].type > 0) {\r\n                        numBrick = numBrick + brick[i][j].type;\r\n                    }\r\n                    brick[i][j].Update();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void updatePaddle(Paddle paddle, Brick[][] brick, Ball ball, AtomicBoolean gameRestarted, AtomicBoolean gameIsRunning,  Render render) {\r\n        if (!gameIsRunning.get()) {\r\n            return;\r\n        }\r\n\r\n        if (heartCount.get() == 0) {\r\n            ball.setBall(paddle.x + paddle.width / 2, HEIGHT - 60);\r\n            return;\r\n        }\r\n\r\n        if (gameRestarted.get()) {\r\n            double nextPaddleX = paddle.getPaddle().getX();\r\n            if (paddle.isMoveLeft()) {\r\n                nextPaddleX -= paddle.vx;\r\n            }\r\n            if (paddle.isMoveRight()) {\r\n                nextPaddleX += paddle.vx;\r\n            }\r\n            nextPaddleX = paddle.ClampPosition(nextPaddleX);\r\n            ball.setBall(paddle.x + paddle.width / 2, HEIGHT - 70);\r\n            paddle.setPaddle(nextPaddleX);\r\n            return;\r\n        }\r\n\r\n        updateBall(ball, brick, paddle, gameRestarted, render);\r\n\r\n        double nextPaddleX = paddle.getPaddle().getX();\r\n        if (paddle.isMoveLeft()) {\r\n            nextPaddleX -= paddle.vx;\r\n        }\r\n        if (paddle.isMoveRight()) {\r\n            nextPaddleX += paddle.vx;\r\n        }\r\n        nextPaddleX = paddle.ClampPosition(nextPaddleX);\r\n        paddle.setPaddle(nextPaddleX);\r\n\r\n    }\r\n\r\n\r\n    private static void updateBall(Ball ball, Brick[][] brick, Paddle paddle, AtomicBoolean gameRestarted, Render render) {\r\n        double nextBallX = ball.getBall().getCenterX() + ball.vx;\r\n        double nextBallY = ball.getBall().getCenterY() + ball.vy;\r\n        ball.setBall(nextBallX, nextBallY);\r\n        switch (ball.checkWallCollision(paddle, gameRestarted)) {\r\n            case -1:\r\n                ball.vx = 0;\r\n                ball.vy = spvxOriginal;\r\n                gameRestarted.set(true);\r\n                heartCount.set(heartCount.get() - 1);\r\n                break;\r\n            case 1:\r\n                ball.vx = -ball.vx;\r\n                ball.vy = -ball.vy;\r\n                break;\r\n            case 2:\r\n                ball.vx = -ball.vx;\r\n                break;\r\n            case 3:\r\n                ball.vy = -ball.vy;\r\n                break;\r\n        }\r\n        int collisionState = ball.checkPaddleCollision(paddle);\r\n        if (ball.isReadyForPaddleCollision(collisionState)) {\r\n            switch (collisionState) {\r\n                case 1:\r\n                    double paddleCenter = paddle.getPaddle().getX() + paddle.getPaddle().getWidth() / 2.0;\r\n                    double offset = Math.abs(paddleCenter - ball.x) / (paddleCenter - paddle.x);\r\n                    double baseAngle = Math.toRadians(45) * offset;\r\n                    if (ball.vx >= 0) {\r\n                        ball.vx = spvxOriginal * Math.sin(baseAngle);\r\n                    } else {\r\n                        ball.vx = -spvxOriginal * Math.sin(baseAngle);\r\n                    }\r\n                    ball.vy = -Math.abs(spvxOriginal * Math.cos(baseAngle));\r\n                    break;\r\n                case 2: case 3:\r\n                    ball.vx = -ball.vx;\r\n                    break;\r\n            }\r\n        }\r\n        int collisionResult = ball.checkBrickCollision(brick, render);\r\n        if (collisionResult != 0) {\r\n            if (collisionResult == 1) {\r\n                ball.vx = -ball.vx;\r\n            } else if (collisionResult == 2) {\r\n                ball.vy = -ball.vy;\r\n            }\r\n            //Brick b = ball.getLastHitBrick();\r\n            // if (b != null) b.BallHit(ball, render);\r\n        }\r\n\r\n    }\r\n}\r\n
===================================================================
diff --git a/src/main/java/LogicGamePlay/Update.java b/src/main/java/LogicGamePlay/Update.java
--- a/src/main/java/LogicGamePlay/Update.java	(revision 7cc99fcd4d56576826d776bd5fdeba716b9bb107)
+++ b/src/main/java/LogicGamePlay/Update.java	(date 1760977005295)
@@ -33,7 +33,7 @@
                 //WIN
             }
         } else {
-            //numBrick--;
+//            numBrick--;
         }
     }
 
Index: src/main/java/LogicGamePlay/Ball.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package LogicGamePlay;\r\n\r\nimport java.util.concurrent.atomic.AtomicBoolean;\r\n\r\nimport javafx.scene.layout.Pane;\r\nimport javafx.scene.paint.Color;\r\nimport javafx.scene.shape.Circle;\r\nimport javafx.scene.canvas.GraphicsContext;\r\n\r\nimport static LogicGamePlay.Specifications.*;\r\n\r\npublic class Ball extends BaseClass {\r\n    private Circle ball;\r\n    private Circle[] Tail = new Circle[TailLength];\r\n    private int[] TailX = new int[TailLength];\r\n    private int[] TailY = new int[TailLength];\r\n    private boolean collidedWithPaddle = false;\r\n\r\n    public Ball() {\r\n        super(null, 0, WIDTH / 2, HEIGHT - 60, spvxOriginal, spvxOriginal, ballRadiusOriginal, ballRadiusOriginal);\r\n        ball = new Circle(x, y, width, Color.BLUE);\r\n        for (int i = 0; i < TailLength; i++) {\r\n            TailX[i] = (int) x;\r\n            TailY[i] = (int) y;\r\n            double density = Math.max(0, 1 - 0.5 - (double) i / (double) TailLength / 2);\r\n            Color ColorTail = new Color(1, 1, 1, density);\r\n            Tail[i] = new Circle(x, y, width - i / 2, ColorTail);\r\n        }\r\n    }\r\n\r\n    public void setBall(double dx, double dy) {\r\n        UpdateTail();\r\n        x = dx;\r\n        y = dy;\r\n        ball.setCenterX(x);\r\n        ball.setCenterY(y);\r\n    }\r\n\r\n    public void UpdateTail() {\r\n        for (int i = TailLength - 1; i > 0; i--) {\r\n            TailX[i] = TailX[i - 1];\r\n            TailY[i] = TailY[i - 1];\r\n            Tail[i].setCenterX(TailX[i]);\r\n            Tail[i].setCenterY(TailY[i]);\r\n        }\r\n        TailX[0] = (int) x;\r\n        TailY[0] = (int) y;\r\n        Tail[0].setCenterX(TailX[0]);\r\n        Tail[0].setCenterY(TailY[0]);\r\n    }\r\n\r\n    public void RenderTail(GraphicsContext gc) {\r\n        for (int i = 0; i < TailLength; i++) {\r\n            Color c = (Color) Tail[i].getFill();\r\n            gc.setFill(c);\r\n            gc.fillOval(TailX[i] - Tail[i].getRadius(),\r\n                    TailY[i] - Tail[i].getRadius(),\r\n                    Tail[i].getRadius() * 3,\r\n                    Tail[i].getRadius() * 3);\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public void Update() {\r\n\r\n    }\r\n\r\n    public Circle getBall() {\r\n        return ball;\r\n    }\r\n\r\n    public int checkWallCollision(Paddle paddle, AtomicBoolean gameRestarted) {\r\n        if (y >= HEIGHT - height) {\r\n            gameRestarted.set(true);\r\n            return -1;\r\n        }\r\n        boolean check1 = x <= width || x >= WIDTH - width;\r\n        boolean check2 = y <= height;\r\n        if (check1 && check2) {\r\n            return 1;\r\n        } else if (check1) {\r\n            return 2;\r\n        } else if (check2) {\r\n            return 3;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    public int checkPaddleCollision(Paddle paddle) {\r\n        double ballX = x;\r\n        double ballY = y;\r\n        double radius = width;\r\n        double paddleLeft = Math.min(paddle.x, paddle.x + paddle.vx);\r\n        double paddleRight = Math.max(paddleLeft + paddle.width, paddleLeft + paddle.width + paddle.vx);\r\n        double paddleTop = paddle.y;\r\n        double paddleBottom = paddleTop + paddle.height;\r\n\r\n        boolean collisionX = ballX + radius >= paddleLeft && ballX - radius <= paddleRight;\r\n        boolean collisionY = ballY + radius >= paddleTop && ballY - radius <= paddleBottom;\r\n\r\n        if (!collisionX || !collisionY) {\r\n            return -1;\r\n        }\r\n        if (ballX <= paddleLeft && !collisionY) {\r\n            return 2;\r\n        } else if (ballX >= paddleRight && !collisionY) {\r\n            return 3;\r\n        }\r\n        return 1;\r\n    }\r\n\r\n    public boolean isReadyForPaddleCollision(int collisionState) {\r\n        if (collisionState != -1 && !collidedWithPaddle) {\r\n            collidedWithPaddle = true;\r\n            return true;\r\n        }\r\n        if (collisionState == -1) {\r\n            collidedWithPaddle = false;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public int checkBrickCollision(Brick[][] brick, Render render) {\r\n        int brickCol = (int) x / (int) WIDTHBrick;\r\n        int brickRow = (int) y / (int) HEIGHTBrick;\r\n\r\n        boolean above = false, below = false, left = false, right = false;\r\n\r\n        if (vy < 0 && brickRow > 0 && brickRow < ROW && (brickRow) * HEIGHTBrick + width >= y) {\r\n            above = true;\r\n        }\r\n        if (vy > 0 && brickRow < ROW - 1 && (brickRow + 1) * HEIGHTBrick - width <= y) {\r\n            below = true;\r\n        }\r\n        if (vx < 0 && brickCol > 0 && brickRow < ROW && (brickCol) * WIDTHBrick + width >= x) {\r\n            left = true;\r\n        }\r\n        if (vx > 0 && brickCol < COL - 1 && brickRow < ROW && (brickCol + 1) * WIDTHBrick - width <= x) {\r\n            right = true;\r\n        }\r\n\r\n        if (above == true) {\r\n            if (brick[brickRow - 1][brickCol].type != 0) {\r\n                brick[brickRow - 1][brickCol].BallHit(this, render);\r\n                return 2;\r\n            }\r\n        }\r\n        if (below == true) {\r\n            if (brick[brickRow + 1][brickCol].type != 0) {\r\n                brick[brickRow + 1][brickCol].BallHit(this, render);\r\n                return 2;\r\n            }\r\n        }\r\n        if (left == true) {\r\n            if (brick[brickRow][brickCol - 1].type != 0) {\r\n                brick[brickRow][brickCol - 1].BallHit(this, render);\r\n                return 1;\r\n            }\r\n        }\r\n        if (right == true) {\r\n            if (brick[brickRow][brickCol + 1].type != 0) {\r\n                brick[brickRow][brickCol + 1].BallHit(this, render);\r\n                return 1;\r\n            }\r\n        }\r\n        if (above == true && left == true) {\r\n            if (brick[brickRow - 1][brickCol - 1].type != 0) {\r\n                brick[brickRow - 1][brickCol - 1].BallHit(this, render);\r\n                if (Math.abs((brickRow) * HEIGHTBrick - (int) y) > Math.abs((brickCol) * WIDTHBrick - (int) x)) {\r\n                    return 2;\r\n                } else {\r\n                    return 1;\r\n                }\r\n            }\r\n        }\r\n        if (below == true && left == true) {\r\n            if (brick[brickRow + 1][brickCol - 1].type != 0) {\r\n                brick[brickRow + 1][brickCol - 1].BallHit(this, render);\r\n                if (Math.abs((brickRow + 1) * HEIGHTBrick - (int) y) > Math.abs((brickCol) * WIDTHBrick - (int) x)) {\r\n                    return 2;\r\n                } else {\r\n                    return 1;\r\n                }\r\n            }\r\n        }\r\n        if (above == true && right == true) {\r\n            if (brick[brickRow - 1][brickCol + 1].type != 0) {\r\n                brick[brickRow - 1][brickCol + 1].BallHit(this, render);\r\n                if (Math.abs((brickRow) * HEIGHTBrick - (int) y) > Math.abs((brickCol + 1) * WIDTHBrick - (int) x)) {\r\n                    return 2;\r\n                } else {\r\n                    return 1;\r\n                }\r\n            }\r\n        }\r\n        if (below == true && right == true) {\r\n            if (brick[brickRow + 1][brickCol + 1].type != 0) {\r\n                brick[brickRow + 1][brickCol + 1].BallHit(this, render);\r\n                if (Math.abs((brickRow + 1) * HEIGHTBrick - (int) y) > Math.abs((brickCol + 1) * WIDTHBrick - (int) x)) {\r\n                    return 2;\r\n                } else {\r\n                    return 1;\r\n                }\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n}
===================================================================
diff --git a/src/main/java/LogicGamePlay/Ball.java b/src/main/java/LogicGamePlay/Ball.java
--- a/src/main/java/LogicGamePlay/Ball.java	(revision 7cc99fcd4d56576826d776bd5fdeba716b9bb107)
+++ b/src/main/java/LogicGamePlay/Ball.java	(date 1760976291552)
@@ -17,7 +17,7 @@
     private boolean collidedWithPaddle = false;
 
     public Ball() {
-        super(null, 0, WIDTH / 2, HEIGHT - 60, spvxOriginal, spvxOriginal, ballRadiusOriginal, ballRadiusOriginal);
+        super(null, 0, WIDTH / 2, HEIGHT - 60, 0, spvxOriginal, ballRadiusOriginal, ballRadiusOriginal);
         ball = new Circle(x, y, width, Color.BLUE);
         for (int i = 0; i < TailLength; i++) {
             TailX[i] = (int) x;
@@ -91,8 +91,8 @@
         double ballX = x;
         double ballY = y;
         double radius = width;
-        double paddleLeft = Math.min(paddle.x, paddle.x + paddle.vx);
-        double paddleRight = Math.max(paddleLeft + paddle.width, paddleLeft + paddle.width + paddle.vx);
+        double paddleLeft = paddle.x;
+        double paddleRight = paddleLeft + paddle.width;
         double paddleTop = paddle.y;
         double paddleBottom = paddleTop + paddle.height;
 
Index: src/main/java/LogicGamePlay/Paddle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package LogicGamePlay;\r\n\r\nimport java.util.concurrent.atomic.AtomicBoolean;\r\n\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.input.KeyCode;\r\nimport javafx.scene.shape.Rectangle;\r\n\r\nimport static LogicGamePlay.Specifications.*;\r\n\r\npublic class Paddle extends BaseClass {\r\n    private Rectangle paddle;\r\n    private boolean moveLeft;\r\n    private boolean moveRight;\r\n\r\n    public Paddle() {\r\n        super(null, 0, WIDTH / 2 - paddleWidthOriginal / 2, HEIGHT - 20, vxOriginal, 0, paddleWidthOriginal, paddleHeightOriginal);\r\n        paddle = new Rectangle(x, y, width, height);\r\n        moveLeft = false;\r\n        moveRight = false;\r\n    }\r\n\r\n    public Rectangle getPaddle() {\r\n        return paddle;\r\n    }\r\n\r\n    public void setPaddle(double dx) {\r\n        x = dx;\r\n        paddle.setX(dx);\r\n    }\r\n\r\n    public boolean isMoveLeft() {\r\n        return moveLeft;\r\n    }\r\n\r\n    public void setMoveLeft(boolean moveLeft) {\r\n        this.moveLeft = moveLeft;\r\n    }\r\n\r\n    public boolean isMoveRight() {\r\n        return moveRight;\r\n    }\r\n\r\n    public void setMoveRight(boolean moveRight) {\r\n        this.moveRight = moveRight;\r\n    }\r\n\r\n    public double ClampPosition(double next) {\r\n        if (next < 0) {\r\n            return 0;\r\n        } else if (next + paddle.getWidth() > WIDTH) {\r\n            return WIDTH - paddle.getWidth();\r\n        }\r\n        return next;\r\n    }\r\n\r\n    @Override\r\n    public void Update() {\r\n\r\n    }\r\n\r\n    public void controllerPaddle(Scene scene, AtomicBoolean gameRestarted) {\r\n        scene.setOnKeyPressed(event -> {\r\n            switch (event.getCode()) {\r\n                case LEFT -> setMoveLeft(true);\r\n                case RIGHT -> setMoveRight(true);\r\n                case SPACE -> gameRestarted.set(!gameRestarted.get());\r\n            }\r\n        });\r\n\r\n        scene.setOnKeyReleased(event -> {\r\n            switch (event.getCode()) {\r\n                case LEFT -> setMoveLeft(false);\r\n                case RIGHT -> setMoveRight(false);\r\n            }\r\n        });\r\n    }\r\n}\r\n
===================================================================
diff --git a/src/main/java/LogicGamePlay/Paddle.java b/src/main/java/LogicGamePlay/Paddle.java
--- a/src/main/java/LogicGamePlay/Paddle.java	(revision 7cc99fcd4d56576826d776bd5fdeba716b9bb107)
+++ b/src/main/java/LogicGamePlay/Paddle.java	(date 1760975370494)
@@ -59,19 +59,28 @@
 
     }
 
-    public void controllerPaddle(Scene scene, AtomicBoolean gameRestarted) {
+    public void controllerPaddle(Scene scene, AtomicBoolean gameRestarted, AtomicBoolean gameIsRunning) {
         scene.setOnKeyPressed(event -> {
             switch (event.getCode()) {
                 case LEFT -> setMoveLeft(true);
+                case A -> setMoveLeft(true);
                 case RIGHT -> setMoveRight(true);
-                case SPACE -> gameRestarted.set(!gameRestarted.get());
+                case D -> setMoveRight(true);
+                case SPACE -> {
+                    if (gameRestarted.get()) {
+                        gameRestarted.set(false);
+                    }
+                }
+                case K -> gameIsRunning.set(!gameIsRunning.get());
             }
         });
 
         scene.setOnKeyReleased(event -> {
             switch (event.getCode()) {
                 case LEFT -> setMoveLeft(false);
+                case A -> setMoveLeft(false);
                 case RIGHT -> setMoveRight(false);
+                case D -> setMoveRight(false);
             }
         });
     }
